<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socratic Orb VFD - v126.0 (Production)</title>
    <style>
        body {
            background-color: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            font-family: monospace;
        }

        /* THE CHASSIS 
           Using the RAW GitHub link to ensure it loads.
        */
        #chassis {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: url('https://raw.githubusercontent.com/Dewsbex/socratic-orb/main/Trim%20Bot%20Dark%20Avenger.png') no-repeat center center;
            background-size: contain;
            /* Keeps the robot fully visible */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* THE VISOR CONTAINER
           This positions the face specifically over the robot's glass eye.
           You may need to tweak 'margin-top' slightly depending on the exact image crop,
           but this centers it logically.
        */
        #visor-aperture {
            position: absolute;
            width: 28vmin;
            /* Responsive size relative to viewport */
            height: 28vmin;
            /* Fine-tune position to sit on the glass */
            top: 48%;
            left: 50%;
            transform: translate(-50%, -50%);

            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        /* THE VFD FACE */
        canvas {
            width: 100%;
            height: 100%;
            /* Adds the CRT/VFD Glow Bloom */
            filter: drop-shadow(0 0 8px cyan) drop-shadow(0 0 16px rgba(0, 255, 255, 0.4));
        }

        .debug {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: #00ffff;
            font-size: 10px;
            opacity: 0.3;
            pointer-events: none;
        }
    </style>
</head>

<body>

    <div id="chassis">
        <div id="visor-aperture">
            <canvas id="orbCanvas" width="640" height="640"></canvas>
        </div>
    </div>
    <div class="debug">SYSTEM: ONLINE // V126.0 // RETINA GRID</div>

    <script>
        /**
         * SOCRATIC ORB ENGINE v126.0 (Fixed)
         * - Fixed: Background Image Loading
         * - Fixed: Grid Resolution (Optimized for sharpness)
         * - Fixed: Mouth Geometry
         */

        const canvas = document.getElementById('orbCanvas');
        const ctx = canvas.getContext('2d');

        // --- 1. CONFIGURATION ---

        // We use a 640x640 grid which maps perfectly to high-DPI screens 
        // without causing the "blocky" aliasing of the 1024 grid.
        const RENDER_SIZE = 640;
        const LOGICAL_SIZE = 320;
        const SCALE = RENDER_SIZE / LOGICAL_SIZE;

        const CONFIG = {
            centerX: 160,
            centerY: 160,
            eyeGap: 38, // Slightly wider for the "cute" look
            eyeW: 34,
            eyeH: 46,
            pupilRadius: 10,
            mouthBaseY: 195,
            color: {
                glow: '#00ffff', // Cyan
                core: '#ffffff', // White
                bg: '#000000'
            },
            physics: {
                accel: 0.15, // Softer movement
                drag: 0.75
            }
        };

        let state = {
            mouse: { x: 0, y: 0, active: false },
            smileFactor: 0.0, // Start neutral
            pupils: {
                left: { x: 0, y: 0, vx: 0, vy: 0 },
                right: { x: 0, y: 0, vx: 0, vy: 0 }
            }
        };

        // --- 2. PRE-RENDER THE VFD GRID ---

        const gridCanvas = document.createElement('canvas');
        gridCanvas.width = RENDER_SIZE;
        gridCanvas.height = RENDER_SIZE;
        const gridCtx = gridCanvas.getContext('2d');

        function initGrid() {
            gridCtx.fillStyle = CONFIG.color.bg;
            gridCtx.fillRect(0, 0, RENDER_SIZE, RENDER_SIZE);

            // Grid Density: 2px dots (High resolution but clean)
            const dotSize = 2;
            const spacing = 3;

            for (let y = 0; y < RENDER_SIZE; y += spacing) {
                for (let x = 0; x < RENDER_SIZE; x += spacing) {
                    // Cyan Glow
                    gridCtx.fillStyle = CONFIG.color.glow;
                    gridCtx.fillRect(x, y, dotSize, dotSize); // Square pixels for VFD look

                    // White Core (Center pixel only)
                    gridCtx.fillStyle = "rgba(255,255,255,0.6)";
                    gridCtx.fillRect(x + 0.5, y + 0.5, 1, 1);
                }
            }
        }
        initGrid();


        // --- 3. PHYSICS & LOGIC ---

        function updatePhysics() {
            // Target Smile: 1.0 if active, 0.2 (slight smile) if idle
            // The "Winking" robot image implies a happy default state.
            let targetSmile = state.mouse.active ? 1.0 : 0.2;
            state.smileFactor += (targetSmile - state.smileFactor) * 0.1;

            // Pupil Physics
            updatePupil('left', -CONFIG.eyeGap);
            updatePupil('right', CONFIG.eyeGap);
        }

        function updatePupil(side, xOffset) {
            const eyeCX = CONFIG.centerX + xOffset;
            const eyeCY = CONFIG.centerY; // Eyes centered vertically
            const pupil = state.pupils[side];
            let targetX = 0, targetY = 0;

            if (state.mouse.active) {
                // Calculate vector from Eye Center to Mouse
                let dx = state.mouse.x - eyeCX;
                let dy = state.mouse.y - eyeCY;

                // Convergence (Cross-eye) Logic
                const distFromCenterAxis = Math.abs(state.mouse.x - CONFIG.centerX);
                if (distFromCenterAxis < 40) {
                    // Smoothly look inward
                    const strength = 1.0 - (distFromCenterAxis / 40);
                    dx += (side === 'left' ? 12 : -12) * strength;
                }

                // Clamp to eye radius
                const angle = Math.atan2(dy, dx);
                const dist = Math.min(Math.sqrt(dx * dx + dy * dy), 12);

                targetX = Math.cos(angle) * dist;
                targetY = Math.sin(angle) * dist;
            }

            // Apply Physics
            pupil.vx += (targetX - pupil.x) * CONFIG.physics.accel;
            pupil.vy += (targetY - pupil.y) * CONFIG.physics.accel;
            pupil.vx *= CONFIG.physics.drag;
            pupil.vy *= CONFIG.physics.drag;
            pupil.x += pupil.vx;
            pupil.y += pupil.vy;
        }


        // --- 4. RENDER CYCLE ---

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Create Shape Buffer
            ctx.save();
            ctx.scale(SCALE, SCALE);

            // Draw Shapes (Solid White)
            ctx.fillStyle = '#fff';

            // Eyes
            ctx.beginPath();
            ctx.ellipse(CONFIG.centerX - CONFIG.eyeGap, CONFIG.centerY, CONFIG.eyeW / 2, CONFIG.eyeH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(CONFIG.centerX + CONFIG.eyeGap, CONFIG.centerY, CONFIG.eyeW / 2, CONFIG.eyeH / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Mouth & Brows
            drawMouth();
            drawBrows();

            ctx.restore();

            // Composite: MASK Grid
            ctx.globalCompositeOperation = 'source-in';
            ctx.drawImage(gridCanvas, 0, 0);

            // Composite: CUT OUT Pupils
            ctx.globalCompositeOperation = 'destination-out';
            ctx.save();
            ctx.scale(SCALE, SCALE);

            // Draw Pupils
            const pL = state.pupils.left;
            const pR = state.pupils.right;

            ctx.beginPath();
            ctx.arc((CONFIG.centerX - CONFIG.eyeGap) + pL.x, CONFIG.centerY + pL.y, CONFIG.pupilRadius, 0, Math.PI * 2);
            ctx.arc((CONFIG.centerX + CONFIG.eyeGap) + pR.x, CONFIG.centerY + pR.y, CONFIG.pupilRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.restore();
            ctx.globalCompositeOperation = 'source-over';

            requestAnimationFrame(() => {
                updatePhysics();
                draw();
            });
        }

        function drawMouth() {
            const s = state.smileFactor;
            const mouthW = 38;
            const cx = CONFIG.centerX;
            const cy = CONFIG.mouthBaseY;

            // Organic Smile Math
            // A smile curves UP, so corners are HIGHER than center.
            // Spec: "Banana" shape.

            const smileHeight = s * 15; // How deep the smile is
            const thickness = 10 + (s * 4);

            ctx.beginPath();

            if (s >= 0) {
                // HAPPY MOUTH (U-shape)
                // Top edge
                ctx.moveTo(cx - mouthW, cy - smileHeight);
                ctx.quadraticCurveTo(cx, cy + smileHeight, cx + mouthW, cy - smileHeight);
                // Bottom edge (return)
                ctx.quadraticCurveTo(cx, cy + smileHeight + thickness, cx - mouthW, cy - smileHeight);
            } else {
                // FROWN MOUTH (Arch-shape)
                // Similar logic inverted
                const f = Math.abs(s);
                ctx.moveTo(cx - mouthW, cy + (f * 10));
                ctx.quadraticCurveTo(cx, cy - (f * 10), cx + mouthW, cy + (f * 10));
                ctx.quadraticCurveTo(cx, cy - (f * 10) + thickness, cx - mouthW, cy + (f * 10));
            }

            ctx.fill();
        }

        function drawBrows() {
            const browY = CONFIG.centerY - 35;
            const offset = state.smileFactor * 5; // Raise brows when smiling
            const tilt = state.smileFactor * 0.2; // Tilt angle

            ctx.save();

            // Left Brow
            ctx.translate(CONFIG.centerX - CONFIG.eyeGap, browY - offset);
            ctx.rotate(-tilt);
            ctx.beginPath();
            ctx.roundRect(-16, -4, 32, 8, 4);
            ctx.fill();
            ctx.restore();

            ctx.save();
            // Right Brow
            ctx.translate(CONFIG.centerX + CONFIG.eyeGap, browY - offset);
            ctx.rotate(tilt); // Mirror tilt
            ctx.beginPath();
            ctx.roundRect(-16, -4, 32, 8, 4);
            ctx.fill();
            ctx.restore();
        }


        // --- 5. INPUT HANDLING ---

        window.addEventListener('mousemove', (e) => {
            state.mouse.active = true;

            // Map window coordinates to canvas logical coordinates
            const rect = canvas.getBoundingClientRect();
            const scaleX = LOGICAL_SIZE / rect.width;
            const scaleY = LOGICAL_SIZE / rect.height;

            state.mouse.x = (e.clientX - rect.left) * scaleX;
            state.mouse.y = (e.clientY - rect.top) * scaleY;
        });

        window.addEventListener('mouseleave', () => {
            state.mouse.active = false;
        });

        // START
        requestAnimationFrame(draw);

    </script>
</body>

</html>