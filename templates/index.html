<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE SOCRATIC ORB | STANDALONE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

        :root {
            --bg-color: #050505;
            --orb-size: min(90vw, 90vh);
            /* responsive scaling */
        }

        body {
            margin: 0;
            background: var(--bg-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
        }

        /* --- THE ORB CONTAINER --- */
        .orb-stage {
            position: relative;
            width: var(--orb-size);
            height: var(--orb-size);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* --- THE ROBOT HULL (Image) --- */
        .orb-hull {
            position: absolute;
            inset: 0;
            /* Standardized relative path for Render static serving */
            background-image: url('/static/trim_bot.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;

            /* THE COLOR POP LOGIC */
            filter: grayscale(100%) contrast(1.2);
            transition: filter 0.8s ease-out;
            z-index: 1;
        }

        /* Hovering anywhere on the screen triggers the color pop */
        body:hover .orb-hull {
            filter: grayscale(0%) contrast(1.0);
        }

        /* --- THE VFD FACE (Canvas) --- */
        #face-canvas {
            position: absolute;
            z-index: 2;
            /* Sits ON TOP of the hull */
            width: 100%;
            height: 100%;
            /* The face is ALWAYS colored, never grayscale */
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.4));
        }

        /* --- UI OVERLAY --- */
        .ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00ffff;
            /* CYAN for visibility */
            font-size: 11px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.6;
            letter-spacing: 0.2em;
            text-transform: uppercase;
        }
    </style>
</head>

<body>

    <div class="orb-stage" id="stage">
        <div class="orb-hull"></div>
        <canvas id="face-canvas"></canvas>
    </div>

    <div class="ui-layer">
        SYSTEM: ONLINE // SOCRATIC ENGINE ACTIVE // v8.0 [RESET-CLEAN]
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            gridRes: 128,        // High density micro-dots
            scale: 0.45,         // Calibrated fit for the glass lens
            trackingRange: 5,    // Eye movement limit
            colors: {
                bg: '#000000',   // Backing behind pixels (Solid state)
                glow: '#00ffff', // High-voltage cyan
                core: '#ffffff'  // White hot center
            }
        };

        // --- SETUP ---
        const canvas = document.getElementById('face-canvas');
        const stage = document.getElementById('stage');
        const ctx = canvas.getContext('2d');

        // Virtual buffer for drawing shapes before pixelating
        const buffer = document.createElement('canvas');
        buffer.width = CONFIG.gridRes;
        buffer.height = CONFIG.gridRes;
        const bCtx = buffer.getContext('2d');

        // State Variables
        let mouseX = 0, mouseY = 0;
        let smileFactor = 0;
        let targetSmile = 0;
        let eyePos = { x: 0, y: 0 };
        let eyeVel = { x: 0, y: 0 };

        // --- RESIZE HANDLER ---
        const handleResize = () => {
            const dpr = window.devicePixelRatio || 1;
            const rect = stage.getBoundingClientRect();

            // Critical: setting canvas size clears transform state
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            // Apply scale once here
            ctx.scale(dpr, dpr);
        };
        window.addEventListener('resize', handleResize);
        handleResize(); // Init

        // --- INPUT TRACKING ---
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            targetSmile = 1.0;
        });

        document.addEventListener('mouseout', () => { targetSmile = 0.0; });

        // --- THE RENDER LOOP ---
        const animate = () => {
            requestAnimationFrame(animate);

            // 1. Physics
            smileFactor += (targetSmile - smileFactor) * 0.1;
            const targetX = Math.max(-1, Math.min(1, mouseX)) * CONFIG.trackingRange;
            const targetY = Math.max(-1, Math.min(1, -mouseY)) * CONFIG.trackingRange;

            eyeVel.x += (targetX - eyePos.x) * 0.1;
            eyeVel.y += (targetY - eyePos.y) * 0.1;
            eyeVel.x *= 0.8;
            eyeVel.y *= 0.8;
            eyePos.x += eyeVel.x;
            eyePos.y += eyeVel.y;

            // 2. DRAW TO BUFFER
            bCtx.clearRect(0, 0, CONFIG.gridRes, CONFIG.gridRes);
            bCtx.save();
            bCtx.translate(CONFIG.gridRes / 2, CONFIG.gridRes / 2);
            bCtx.scale(CONFIG.scale, CONFIG.scale);
            bCtx.translate(-CONFIG.gridRes / 2, -CONFIG.gridRes / 2);

            const cx = CONFIG.gridRes / 2;
            const cy = CONFIG.gridRes * 0.48;
            bCtx.fillStyle = '#FFF';
            bCtx.strokeStyle = '#FFF';

            // EYES
            const eyeW = 14; const eyeH = 20; const eyeGap = 28;
            [-1, 1].forEach(side => {
                bCtx.beginPath();
                bCtx.ellipse(cx + (eyeGap * side) + eyePos.x, cy + eyePos.y, eyeW / 2, eyeH / 2, 0, 0, Math.PI * 2);
                bCtx.fill();
            });

            // BROWS
            const browY = cy - 20 + (eyePos.y * 0.7);
            const browW = 24; const browAngle = smileFactor * 0.3;
            bCtx.lineWidth = 5; bCtx.lineCap = 'round';
            [-1, 1].forEach(side => {
                bCtx.save();
                bCtx.translate(cx + (eyeGap * side) + eyePos.x, browY);
                bCtx.rotate(browAngle * side);
                bCtx.beginPath();
                bCtx.moveTo(-browW / 2, 4); bCtx.quadraticCurveTo(0, -6, browW / 2, 4);
                bCtx.stroke();
                bCtx.restore();
            });

            // MOUTH
            const mouthY = cy + 28; const mouthW = 32;
            const smileDepth = smileFactor * 14;
            if (smileFactor > 0.1) {
                bCtx.beginPath();
                bCtx.moveTo(cx - mouthW, mouthY);
                bCtx.quadraticCurveTo(cx, mouthY + smileDepth, cx + mouthW, mouthY - (6 * smileFactor));
                bCtx.quadraticCurveTo(cx, mouthY + smileDepth + 10, cx - mouthW, mouthY);
                bCtx.fill();
            } else {
                bCtx.beginPath();
                bCtx.moveTo(cx - mouthW, mouthY);
                bCtx.quadraticCurveTo(cx, mouthY, cx + mouthW, mouthY);
                bCtx.stroke();
            }

            bCtx.restore();

            // 3. RENDER PIXELS (Using canvas-level shadow only for performance)
            ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);

            const data = bCtx.getImageData(0, 0, CONFIG.gridRes, CONFIG.gridRes).data;
            const stageW = stage.clientWidth;
            const dotSize = stageW / CONFIG.gridRes;
            const radius = (dotSize / 2) * 1.15;

            // Optimization: avoid shadowBlur in internal loop
            for (let y = 0; y < CONFIG.gridRes; y++) {
                for (let x = 0; x < CONFIG.gridRes; x++) {
                    const idx = (y * CONFIG.gridRes + x) * 4;
                    if (data[idx + 3] > 100) {
                        const sx = x * dotSize + (dotSize / 2);
                        const sy = y * dotSize + (dotSize / 2);

                        // Layer 1: Black Backing
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius * 1.2, 0, Math.PI * 2);
                        ctx.fillStyle = CONFIG.colors.bg;
                        ctx.fill();

                        // Layer 2: Neon Core (The glow is handled by the canvas CSS filter)
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius, 0, Math.PI * 2);
                        ctx.fillStyle = CONFIG.colors.glow;
                        ctx.fill();

                        // Layer 3: White Core
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius * 0.6, 0, Math.PI * 2);
                        ctx.fillStyle = CONFIG.colors.core;
                        ctx.fill();
                    }
                }
            }
        };

        animate();
    </script>
</body>

</html>