<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE SOCRATIC ORB | v125.1-FINAL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

        /* v125.1 CLEAN NAMESPACE */
        :root {
            --v125-bg: #000000;
            --v125-cyan: #00ffff;
            --v125-white: #ffffff;
            --v125-size: min(90vw, 90vh);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            background: var(--v125-bg);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
        }

        /* --- THE STAGE --- */
        .v125-stage {
            position: relative;
            width: var(--v125-size);
            height: var(--v125-size);
            /* Centering Context */
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            border-radius: 50%;
            /* Temp circular mask */
        }

        /* --- THE HULL --- */
        .v125-hull {
            position: absolute;
            inset: 0;
            /* FALLBACK COLOR IN CASE IMAGE 404s */
            background-color: #111;
            background-image: url('/static/socratic_hull_v135.png?v=125.1');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
            pointer-events: none;
        }

        /* --- THE FACE CANVAS --- */
        #v125-face {
            position: absolute;
            z-index: 2;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Hardware Accelerated Glow */
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
        }

        /* --- FOOTER --- */
        .v125-footer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: var(--v125-cyan);
            font-size: 10px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.9;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
        }
    </style>
</head>

<body>

    <div class="v125-stage" id="stage">
        <div class="v125-hull"></div>
        <canvas id="v125-face"></canvas>
    </div>

    <div class="v125-footer">
        SYSTEM: ONLINE // ENGINE: v125.1-FIXED [STABLE]
    </div>

    <script>
        // --- CACHE CLEANER ---
        (function () { try { localStorage.clear(); sessionStorage.clear(); } catch (e) { } })();

        // --- 1. CONFIGURATION ---
        const SPEC = {
            logic: 320,        // Logical Coordinate Space
            scale: 0.85,       // Visor Fit Scale
            center: { x: 160, y: 153.6 },
            grid: {
                res: 1024,     // Texture Resolution
                density: 1000, // Dots per axis
                overlap: 1.6,  // Phosphor bleed
                bg: '#000000',
                glow: '#00ffff',
                core: '#ffffff'
            }
        };

        // --- 2. INIT & STATE ---
        const canvas = document.getElementById('v125-face');
        const stage = document.getElementById('stage');
        const ctx = canvas.getContext('2d', { alpha: true });

        // VFD GRID TEXTURE (Pre-Rendered)
        const gridCanvas = document.createElement('canvas');
        gridCanvas.width = SPEC.grid.res;
        gridCanvas.height = SPEC.grid.res;
        const gCtx = gridCanvas.getContext('2d');

        // LOGIC BUFFER (MOVED OUTSIDE RENDER LOOP)
        const logicCanvas = document.createElement('canvas');
        logicCanvas.width = SPEC.logic;
        logicCanvas.height = SPEC.logic;
        const lCtx = logicCanvas.getContext('2d');

        // PHYSICS STATE
        const state = {
            mouse: { x: 160, y: 320 }, // Default Low
            smile: -0.5,
            targetSmile: -0.5,
            pupilL: { x: 0, y: 0, vx: 0, vy: 0 },
            pupilR: { x: 0, y: 0, vx: 0, vy: 0 },
            isIdle: true
        };

        // --- 3. PRE-RENDER GRID TEXTURE ---
        const generateGrid = () => {
            const step = SPEC.grid.res / SPEC.grid.density;
            const radius = (step / 2) * SPEC.grid.overlap;

            gCtx.fillStyle = SPEC.grid.bg;
            gCtx.fillRect(0, 0, SPEC.grid.res, SPEC.grid.res);

            // Optimization: Only draw dots, don't overdraw
            for (let y = 0; y < SPEC.grid.res; y += step) {
                for (let x = 0; x < SPEC.grid.res; x += step) {
                    gCtx.beginPath();
                    gCtx.arc(x + step / 2, y + step / 2, radius * 0.98, 0, Math.PI * 2);
                    gCtx.fillStyle = SPEC.grid.glow;
                    gCtx.fill();

                    gCtx.beginPath();
                    gCtx.arc(x + step / 2, y + step / 2, radius * 0.90, 0, Math.PI * 2);
                    gCtx.fillStyle = SPEC.grid.core;
                    gCtx.fill();
                }
            }
        };
        generateGrid();

        // --- 4. RESIZE HANDLER ---
        const handleResize = () => {
            const dpr = window.devicePixelRatio || 1;
            const rect = stage.getBoundingClientRect();

            // Safety check for 0-size (hidden) elements
            if (rect.width === 0 || rect.height === 0) return;

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            ctx.imageSmoothingEnabled = false; // Keep it retro/sharp
        };
        window.addEventListener('resize', handleResize);

        // Ensure layout is ready before first resize
        setTimeout(handleResize, 50);

        // --- 5. INPUT HANDLING ---
        document.addEventListener('mousemove', (e) => {
            state.isIdle = false;
            state.targetSmile = 1.0;

            // Accurate Mouse Mapping
            const rect = stage.getBoundingClientRect();
            const relX = (e.clientX - rect.left) / rect.width;
            const relY = (e.clientY - rect.top) / rect.height;

            state.mouse.x = relX * SPEC.logic;
            state.mouse.y = relY * SPEC.logic;
        });

        document.addEventListener('mouseleave', () => {
            state.isIdle = true;
            state.targetSmile = -0.5;
            state.mouse.x = SPEC.center.x;
            state.mouse.y = SPEC.center.y + 100; // Look down
        });

        // --- 6. RENDER FRAME ---
        const render = () => {
            // A. PHYSICS STEP
            state.smile += (state.targetSmile - state.smile) * 0.12;

            // Eye Convergence Logic
            const solveEye = (eyeCX, eyeCY, currentPos) => {
                let dx = state.mouse.x - eyeCX;
                let dy = state.mouse.y - eyeCY;

                const dist = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / (dist || 1);
                const ny = dy / (dist || 1);

                const distFromCenter = Math.abs(state.mouse.x - SPEC.center.x);
                let convergenceX = 0;
                if (distFromCenter < 40) {
                    const strength = 1.0 - (distFromCenter / 40);
                    convergenceX = (eyeCX < SPEC.center.x) ? 16 * strength : -16 * strength;
                }

                const lookMag = Math.min(dist, 11);
                const targetX = (nx * lookMag) + convergenceX;
                const targetY = (ny * lookMag);

                currentPos.vx += (targetX - currentPos.x) * 0.2;
                currentPos.vy += (targetY - currentPos.y) * 0.2;
                currentPos.vx *= 0.7;
                currentPos.vy *= 0.7;
                currentPos.x += currentPos.vx;
                currentPos.y += currentPos.vy;
            };

            const leftEyeCX = 125 + SPEC.center.x - 160;
            const rightEyeCX = 195 + SPEC.center.x - 160;
            const eyeCY = SPEC.center.y;

            solveEye(125, 153.6, state.pupilL);
            solveEye(195, 153.6, state.pupilR);


            // B. DRAWING PIPELINE (Reuse Buffer!)
            // Clear Logic Buffer
            lCtx.globalCompositeOperation = 'source-over';
            lCtx.clearRect(0, 0, SPEC.logic, SPEC.logic);

            // 1. Draw White Shapes (Source)
            lCtx.fillStyle = '#FFFFFF';
            lCtx.strokeStyle = '#FFFFFF';
            lCtx.lineCap = 'round';
            lCtx.save(); // Save context state before transforms
            lCtx.translate(SPEC.center.x, SPEC.center.y);
            lCtx.scale(SPEC.scale, SPEC.scale);
            lCtx.translate(-SPEC.center.x, -SPEC.center.y);

            const cx = SPEC.center.x;
            const cy = SPEC.center.y;

            // Eyes
            [125, 195].forEach((ex) => {
                lCtx.beginPath();
                lCtx.ellipse(ex, cy, 16, 22, 0, 0, Math.PI * 2);
                lCtx.fill();
            });

            // Brows
            const browY = cy - 30;
            const arch = state.smile * -8;
            [-1, 1].forEach(side => {
                lCtx.save();
                const bx = cx + (35 * side);
                lCtx.translate(bx, browY);
                lCtx.lineWidth = 6;
                lCtx.beginPath();
                lCtx.moveTo(-14, 4);
                lCtx.quadraticCurveTo(0, -4 + arch, 14, 4);
                lCtx.stroke();
                lCtx.restore();
            });

            // Mouth
            const mouthY = 187.6;
            const mw = 42;
            const mt = 12 + (Math.abs(state.smile) * 10);
            const mCurve = (state.smile > 0) ? state.smile * 25 : state.smile * 35;

            lCtx.beginPath();
            lCtx.moveTo(cx - mw, mouthY);
            lCtx.quadraticCurveTo(cx, mouthY + mCurve - mt, cx + mw, mouthY);
            lCtx.quadraticCurveTo(cx, mouthY + mCurve + mt, cx - mw, mouthY);
            lCtx.fill();

            lCtx.restore(); // Restore scale/translate


            // 2. Composite Grid (Mask)
            lCtx.globalCompositeOperation = 'source-in';
            // Draw high-res grid into low-res buffer
            lCtx.drawImage(gridCanvas, 0, 0, SPEC.logic, SPEC.logic);

            // 3. Cut Pupils (Destination Out)
            lCtx.globalCompositeOperation = 'destination-out';

            // Left Pupil
            lCtx.beginPath();
            lCtx.arc(125 + state.pupilL.x, 153.6 + state.pupilL.y, 11, 0, Math.PI * 2);
            lCtx.fill();

            // Right Pupil
            lCtx.beginPath();
            lCtx.arc(195 + state.pupilR.x, 153.6 + state.pupilR.y, 11, 0, Math.PI * 2);
            lCtx.fill();


            // C. FINAL RENDER TO SCREEN
            // Clear Screen
            const dpr = window.devicePixelRatio || 1;
            ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr);

            // Draw Logic Buffer Scaled to Stage
            ctx.drawImage(logicCanvas,
                0, 0, SPEC.logic, SPEC.logic,
                0, 0, stage.clientWidth, stage.clientHeight
            );

            requestAnimationFrame(render);
        };

        render();
    </script>
</body>

</html>