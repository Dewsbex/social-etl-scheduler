<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE SOCRATIC ORB | STANDALONE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

        :root {
            --bg-color: #050505;
            --orb-size: min(90vw, 90vh);
            /* responsive scaling */
        }

        body {
            margin: 0;
            background: var(--bg-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
        }

        /* --- THE ORB CONTAINER --- */
        /* This keeps the aspect ratio locked so the face never drifts */
        .orb-stage {
            position: relative;
            width: var(--orb-size);
            height: var(--orb-size);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* --- THE ROBOT HULL (Image) --- */
        .orb-hull {
            position: absolute;
            inset: 0;
            background-image: url('https://raw.githubusercontent.com/Dewsbex/Vibe-Station-Alpha/main/Blank%20Bot%20Dark%20Avenger.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;

            /* THE COLOR POP LOGIC */
            filter: grayscale(100%) contrast(1.2);
            transition: filter 0.8s ease-out;
            z-index: 1;
        }

        /* Hovering anywhere on the screen triggers the color pop */
        body:hover .orb-hull {
            filter: grayscale(0%) contrast(1.0);
        }

        /* --- THE VFD FACE (Canvas) --- */
        #face-canvas {
            position: absolute;
            z-index: 2;
            /* Sits ON TOP of the hull */
            width: 100%;
            height: 100%;
            /* The face is ALWAYS colored, never grayscale */
            filter: drop-shadow(0 0 20px rgba(0, 255, 255, 0.4));
        }

        /* --- UI OVERLAY --- */
        .ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #444;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.5;
            letter-spacing: 0.2em;
        }
    </style>
</head>

<body>

    <div class="orb-stage" id="stage">
        <div class="orb-hull"></div>
        <canvas id="face-canvas"></canvas>
    </div>

    <div class="ui-layer">
        SYSTEM: ONLINE // SOCRATIC ENGINE ACTIVE // v6.0 [FORCE-SYNC]
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            gridRes: 128,        // High density micro-dots
            scale: 0.45,         // Calibrated fit for the glass lens
            trackingRange: 5,    // Eye movement limit
            colors: {
                bg: '#000000',   // Backing behind pixels (Solid state)
                glow: '#00ffff', // High-voltage cyan
                core: '#ffffff'  // White hot center
            }
        };

        // --- SETUP ---
        const canvas = document.getElementById('face-canvas');
        const stage = document.getElementById('stage');
        const ctx = canvas.getContext('2d');

        // Virtual buffer for drawing shapes before pixelating
        const buffer = document.createElement('canvas');
        buffer.width = CONFIG.gridRes;
        buffer.height = CONFIG.gridRes;
        const bCtx = buffer.getContext('2d');

        // State Variables
        let mouseX = 0, mouseY = 0;
        let smileFactor = 0;
        let targetSmile = 0;
        let eyePos = { x: 0, y: 0 };
        let eyeVel = { x: 0, y: 0 };

        // --- RESIZE HANDLER ---
        const handleResize = () => {
            // Retina scaling for sharpness
            const dpr = window.devicePixelRatio || 1;
            const rect = stage.getBoundingClientRect();

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;

            ctx.scale(dpr, dpr);
        };
        window.addEventListener('resize', handleResize);
        handleResize(); // Init

        // --- INPUT TRACKING ---
        document.addEventListener('mousemove', (e) => {
            // Normalize mouse position (-1 to 1) from center of screen
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            targetSmile = 1.0; // Smile when interacting
        });

        // Reset when mouse leaves window
        document.addEventListener('mouseout', () => { targetSmile = 0.0; });

        // --- THE RENDER LOOP ---
        const animate = () => {
            requestAnimationFrame(animate);

            // 1. Physics & Interpolation
            smileFactor += (targetSmile - smileFactor) * 0.1;

            // Eye Tracking Physics
            const targetX = Math.max(-1, Math.min(1, mouseX)) * CONFIG.trackingRange;
            const targetY = Math.max(-1, Math.min(1, -mouseY)) * CONFIG.trackingRange;

            eyeVel.x += (targetX - eyePos.x) * 0.1;
            eyeVel.y += (targetY - eyePos.y) * 0.1;
            eyeVel.x *= 0.8; // Friction
            eyeVel.y *= 0.8;
            eyePos.x += eyeVel.x;
            eyePos.y += eyeVel.y;

            // 2. DRAW SHAPES TO VIRTUAL BUFFER
            bCtx.clearRect(0, 0, CONFIG.gridRes, CONFIG.gridRes);
            bCtx.save();

            // Center & Scale
            bCtx.translate(CONFIG.gridRes / 2, CONFIG.gridRes / 2);
            bCtx.scale(CONFIG.scale, CONFIG.scale);
            bCtx.translate(-CONFIG.gridRes / 2, -CONFIG.gridRes / 2);

            bCtx.fillStyle = '#FFF';
            bCtx.strokeStyle = '#FFF';
            bCtx.lineCap = 'round';

            const cx = CONFIG.gridRes / 2;
            const cy = CONFIG.gridRes * 0.48; // Optical center

            // --> EYES (Symmetrical Vertical Pills)
            const eyeW = 14; const eyeH = 20; const eyeGap = 28;

            [-1, 1].forEach(side => {
                bCtx.beginPath();
                bCtx.ellipse(
                    cx + (eyeGap * side) + eyePos.x,
                    cy + eyePos.y,
                    eyeW / 2, eyeH / 2,
                    0, 0, Math.PI * 2
                );
                bCtx.fill();
            });

            // --> BROWS (Arched & Dampened)
            const browY = cy - 20 + (eyePos.y * 0.7); // Dampened Y movement
            const browW = 24;
            const browAngle = smileFactor * 0.3;
            bCtx.lineWidth = 5;

            // Left Brow
            bCtx.save();
            bCtx.translate(cx - eyeGap + eyePos.x, browY);
            bCtx.rotate(-browAngle);
            bCtx.beginPath();
            bCtx.moveTo(-browW / 2, 4);
            bCtx.quadraticCurveTo(0, -6, browW / 2, 4);
            bCtx.stroke();
            bCtx.restore();

            // Right Brow
            bCtx.save();
            bCtx.translate(cx + eyeGap + eyePos.x, browY);
            bCtx.rotate(browAngle);
            bCtx.beginPath();
            bCtx.moveTo(-browW / 2, 4);
            bCtx.quadraticCurveTo(0, -6, browW / 2, 4);
            bCtx.stroke();
            bCtx.restore();

            // --> MOUTH (Wide Crescent)
            const mouthY = cy + 28;
            const mouthW = 32;
            const smileDepth = smileFactor * 14;
            const skewY = (smileFactor > 0) ? -6 * smileFactor : 0; // Smirk lift

            if (smileFactor > 0.1) {
                // The "Banana" Shape
                bCtx.beginPath();
                bCtx.moveTo(cx - mouthW, mouthY);
                // Top Lip
                bCtx.quadraticCurveTo(cx, mouthY + smileDepth, cx + mouthW, mouthY + skewY);
                // Bottom Lip (Thicker center)
                bCtx.quadraticCurveTo(cx, mouthY + smileDepth + 10, cx - mouthW, mouthY);
                bCtx.fill();
            } else {
                // Neutral Line
                bCtx.lineWidth = 5;
                bCtx.beginPath();
                bCtx.moveTo(cx - mouthW, mouthY);
                bCtx.quadraticCurveTo(cx, mouthY, cx + mouthW, mouthY);
                bCtx.stroke();
            }

            bCtx.restore();

            // 3. RENDER PIXELS TO SCREEN (Micro-Dot Array)
            // Clear Screen
            ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);

            // Get pixel data
            const data = bCtx.getImageData(0, 0, CONFIG.gridRes, CONFIG.gridRes).data;
            const stageW = stage.clientWidth;
            const dotSize = stageW / CONFIG.gridRes;
            const radius = (dotSize / 2) * 1.15; // 15% overlap for solid look

            for (let y = 0; y < CONFIG.gridRes; y++) {
                for (let x = 0; x < CONFIG.gridRes; x++) {
                    const idx = (y * CONFIG.gridRes + x) * 4;
                    // Check alpha channel
                    if (data[idx + 3] > 100) {
                        const sx = x * dotSize + (dotSize / 2);
                        const sy = y * dotSize + (dotSize / 2);

                        // Layer 1: Black Backing (Opacity)
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius * 1.2, 0, Math.PI * 2);
                        ctx.fillStyle = CONFIG.colors.bg;
                        ctx.fill();

                        // Layer 2: Neon Glow
                        ctx.beginPath();
                        ctx.arc(sx, sy, radius, 0, Math.PI * 2);
                        ctx.fillStyle = CONFIG.colors.glow;
                        ctx.shadowColor = CONFIG.colors.glow;
                        ctx.shadowBlur = dotSize * 0.8;
                        ctx.fill();

                        // Layer 3: White Core
                        ctx.beginPath();
                        ctx.shadowBlur = 0;
                        ctx.arc(sx, sy, radius * 0.6, 0, Math.PI * 2);
                        ctx.fillStyle = CONFIG.colors.core;
                        ctx.fill();
                    }
                }
            }
        };

        // Start Engine
        animate();
    </script>
</body>

</html>