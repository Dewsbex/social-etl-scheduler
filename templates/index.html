<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE SOCRATIC ORB | v135.0</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

        /* v135 CLEAN NAMESPACE */
        :root {
            --socratic-bg: #000000;
            --socratic-cyan: #00ffff;
            --socratic-white: #ffffff;
            --socratic-size: min(90vw, 90vh);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            background: var(--socratic-bg);
            height: 100%;
            width: 100%;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
        }

        /* --- THE STAGE --- */
        .socratic-v135-stage {
            position: relative;
            width: var(--socratic-size);
            height: var(--socratic-size);
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            /* Solid black background */
        }

        /* --- THE HULL --- */
        .socratic-v135-hull {
            position: absolute;
            inset: 0;
            background-image: url('/static/socratic_hull_v135.png?v=135');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        /* --- THE FACE CANVAS --- */
        #socratic-v135-canvas {
            position: absolute;
            z-index: 2;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* High-performance hardware glow */
            filter: drop-shadow(0 0 12px rgba(0, 255, 255, 0.45));
        }

        /* --- THE FOOTER --- */
        .socratic-v135-footer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: var(--socratic-cyan);
            font-size: 10px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.9;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
        }
    </style>
</head>

<body>

    <div class="socratic-v135-stage" id="socratic-stage">
        <div class="socratic-v135-hull" id="socratic-hull"></div>
        <canvas id="socratic-v135-canvas"></canvas>
    </div>

    <div class="socratic-v135-footer">
        SYSTEM: ONLINE // ENGINE: v135.0 [CACHE-KILLER] // SOVEREIGN SENTINEL
    </div>

    <script>
        // --- CACHE & SERVICE WORKER KILLER ---
        (function () {
            localStorage.clear();
            sessionStorage.clear();
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(function (registrations) {
                    for (let registration of registrations) {
                        registration.unregister();
                        console.log("Service Worker Unregistered");
                    }
                });
            }
        })();

        // --- SPECIFICATION v125.0 ---
        const SPEC = {
            gridRes: 1024,
            logicSize: 320,
            center: { x: 160, y: 153.6 },
            visorScale: 0.85,
            colors: {
                bg: '#000000',
                glow: '#00ffff',
                core: '#ffffff'
            },
            dotsPerAxis: 1000,
            overlap: 1.6
        };

        const canvas = document.getElementById('socratic-v135-canvas');
        const stage = document.getElementById('socratic-stage');
        const ctx = canvas.getContext('2d', { alpha: true });

        const buffer = document.createElement('canvas');
        buffer.width = SPEC.logicSize;
        buffer.height = SPEC.logicSize;
        const bCtx = buffer.getContext('2d');

        let mouseX = 0, mouseY = 0, smileFactor = -0.5, targetSmile = -0.5;
        let eyePos = { x: 0, y: 0 }, eyeVel = { x: 0, y: 0 };
        let isOffScreen = true;

        const init = () => {
            const dpr = window.devicePixelRatio || 1;
            const rect = stage.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        };
        window.addEventListener('resize', init);
        init();

        document.addEventListener('mousemove', (e) => {
            isOffScreen = false;
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            targetSmile = 1.0;
        });

        document.addEventListener('mouseleave', () => {
            isOffScreen = true;
            targetSmile = -0.5;
        });

        const drawFace = () => {
            bCtx.clearRect(0, 0, SPEC.logicSize, SPEC.logicSize);
            bCtx.save();
            bCtx.translate(SPEC.center.x, SPEC.center.y);
            bCtx.scale(SPEC.visorScale, SPEC.visorScale);
            bCtx.translate(-SPEC.center.x, -SPEC.center.y);

            const cx = SPEC.center.x;
            const cy = SPEC.center.y;

            // Pill Eyes + Hollow Core
            const eyeW = 32, eyeH = 44, eyeGap = 35, pupilR = 11;
            [-1, 1].forEach(side => {
                const ex = cx + (eyeGap * side) + eyePos.x;
                const ey = cy + eyePos.y;
                bCtx.fillStyle = '#FFF';
                bCtx.beginPath();
                bCtx.ellipse(ex, ey, eyeW / 2, eyeH / 2, 0, 0, Math.PI * 2);
                bCtx.fill();
                bCtx.globalCompositeOperation = 'destination-out';
                bCtx.beginPath();
                bCtx.arc(ex + (eyePos.x * 0.2), ey + (eyePos.y * 0.2), pupilR, 0, Math.PI * 2);
                bCtx.fill();
                bCtx.globalCompositeOperation = 'source-over';
            });

            // Tapered Mouth
            const mouthW = 42, mouthY = cy + 34;
            const thick = 6 + (Math.abs(smileFactor) * 5);
            const curve = (smileFactor > 0) ? smileFactor * 12 : smileFactor * 18;
            const cornerY = (smileFactor < 0) ? -smileFactor * 8 : 0;
            bCtx.fillStyle = '#FFF';
            bCtx.beginPath();
            bCtx.moveTo(cx - mouthW, mouthY + cornerY);
            bCtx.quadraticCurveTo(cx, mouthY + curve - thick, cx + mouthW, mouthY + cornerY);
            bCtx.quadraticCurveTo(cx, mouthY + curve + thick, cx - mouthW, mouthY + cornerY);
            bCtx.fill();

            // Brows
            const browW = 32, browY = cy - 30;
            bCtx.strokeStyle = '#FFF'; bCtx.lineWidth = 4; bCtx.lineCap = 'round';
            [-1, 1].forEach(side => {
                bCtx.save();
                bCtx.translate(cx + (eyeGap * side) + (eyePos.x * 0.5), browY + (eyePos.y * 0.5));
                bCtx.rotate(side * (smileFactor * 0.2));
                bCtx.beginPath();
                bCtx.moveTo(-browW / 2, 5);
                bCtx.quadraticCurveTo(0, -5 - (smileFactor * 5), browW / 2, 5);
                bCtx.stroke();
                bCtx.restore();
            });
            bCtx.restore();
        };

        const loop = () => {
            smileFactor += (targetSmile - smileFactor) * 0.12;
            const pX = isOffScreen ? 0 : mouseX * 8, pY = isOffScreen ? 0 : -mouseY * 8;
            eyeVel.x += (pX - eyePos.x) * 0.2; eyeVel.y += (pY - eyePos.y) * 0.2;
            eyeVel.x *= 0.7; eyeVel.y *= 0.7; eyePos.x += eyeVel.x; eyePos.y += eyeVel.y;

            drawFace();
            ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
            const scale = stage.clientWidth / SPEC.logicSize;
            const data = bCtx.getImageData(0, 0, SPEC.logicSize, SPEC.logicSize).data;
            const dotStep = SPEC.logicSize / SPEC.dotsPerAxis;
            const dotR = (dotStep / 2) * SPEC.overlap;

            for (let y = 0; y < SPEC.logicSize; y += dotStep) {
                for (let x = 0; x < SPEC.logicSize; x += dotStep) {
                    const idx = (Math.floor(y) * SPEC.logicSize + Math.floor(x)) * 4;
                    if (data[idx + 3] > 120) {
                        const sx = x * scale, sy = y * scale, r = dotR * scale;
                        ctx.beginPath();
                        ctx.arc(sx, sy, r * 0.98, 0, Math.PI * 2);
                        ctx.fillStyle = SPEC.colors.glow;
                        ctx.fill();
                        ctx.beginPath();
                        ctx.arc(sx, sy, r * 0.9, 0, Math.PI * 2);
                        ctx.fillStyle = SPEC.colors.core;
                        ctx.fill();
                    }
                }
            }
            requestAnimationFrame(loop);
        };
        loop();
        console.log("v135.0 CACHE-KILLER INITIALIZED");
    </script>
</body>

</html>