<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE SOCRATIC ORB | v125.1-FINAL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

        /* v125.1 CLEAN NAMESPACE */
        :root {
            --v125-bg: #000000;
            --v125-cyan: #00ffff;
            --v125-white: #ffffff;
            --v125-size: min(90vw, 90vh);
        }

        body,
        html {
            margin: 0;
            padding: 0;
            background: var(--v125-bg);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
        }

        /* --- THE STAGE --- */
        .v125-stage {
            position: relative;
            width: var(--v125-size);
            height: var(--v125-size);
            /* Centering Context */
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }

        /* --- THE HULL --- */
        .v125-hull {
            position: absolute;
            inset: 0;
            /* LOADING THE LOCAL ASSET AS REQUESTED */
            background-image: url('/static/socratic_hull_v135.png?v=125.1');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
            /* Optimize for sharpness */
            image-rendering: -webkit-optimize-contrast;
            image-rendering: crisp-edges;
        }

        /* --- THE FACE CANVAS --- */
        #v125-face {
            position: absolute;
            z-index: 2;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Hardware Accelerated Glow */
            filter: drop-shadow(0 0 10px rgba(0, 255, 255, 0.5));
        }

        /* --- FOOTER --- */
        .v125-footer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: var(--v125-cyan);
            font-size: 10px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.9;
            letter-spacing: 0.25em;
            text-transform: uppercase;
            text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
        }
    </style>
</head>

<body>

    <div class="v125-stage" id="stage">
        <div class="v125-hull"></div>
        <canvas id="v125-face"></canvas>
    </div>

    <div class="v125-footer">
        SYSTEM: ONLINE // ENGINE: v125.1-FINAL [ANTIGRAVITY]
    </div>

    <script>
        // --- CACHE CLEANER ---
        (function () { try { localStorage.clear(); sessionStorage.clear(); } catch (e) { } })();

        // --- 1. CONFIGURATION ---
        const SPEC = {
            logic: 320,        // Logical Coordinate Space
            scale: 0.85,       // Visor Fit Scale
            center: { x: 160, y: 153.6 },
            grid: {
                res: 1024,     // Texture Resolution
                density: 1000, // Dots per axis
                overlap: 1.6,  // Phosphor bleed
                bg: '#000000',
                glow: '#00ffff',
                core: '#ffffff'
            }
        };

        // --- 2. INIT & STATE ---
        const canvas = document.getElementById('v125-face');
        const stage = document.getElementById('stage');
        const ctx = canvas.getContext('2d', { alpha: true });

        // VFD GRID TEXTURE (Pre-Rendered)
        const gridCanvas = document.createElement('canvas');
        gridCanvas.width = SPEC.grid.res;
        gridCanvas.height = SPEC.grid.res;
        const gCtx = gridCanvas.getContext('2d');

        // PHYSICS STATE
        const state = {
            mouse: { x: 160, y: 320 }, // Default Low
            smile: -0.5,
            targetSmile: -0.5,
            pupilL: { x: 0, y: 0, vx: 0, vy: 0 },
            pupilR: { x: 0, y: 0, vx: 0, vy: 0 },
            isIdle: true
        };

        // --- 3. PRE-RENDER GRID TEXTURE ---
        const generateGrid = () => {
            const step = SPEC.grid.res / SPEC.grid.density;
            const radius = (step / 2) * SPEC.grid.overlap;

            gCtx.fillStyle = SPEC.grid.bg;
            gCtx.fillRect(0, 0, SPEC.grid.res, SPEC.grid.res);

            for (let y = 0; y < SPEC.grid.res; y += step) {
                for (let x = 0; x < SPEC.grid.res; x += step) {
                    // Cyan Glow
                    gCtx.beginPath();
                    gCtx.arc(x + step / 2, y + step / 2, radius * 0.98, 0, Math.PI * 2);
                    gCtx.fillStyle = SPEC.grid.glow;
                    gCtx.fill();

                    // White Core
                    gCtx.beginPath();
                    gCtx.arc(x + step / 2, y + step / 2, radius * 0.90, 0, Math.PI * 2);
                    gCtx.fillStyle = SPEC.grid.core;
                    gCtx.fill();
                }
            }
        };
        generateGrid(); // Run Once

        // --- 4. RESIZE HANDLER ---
        const handleResize = () => {
            const dpr = window.devicePixelRatio || 1;
            const rect = stage.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            // Re-apply smoothing if reset
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
        };
        window.addEventListener('resize', handleResize);
        handleResize();

        // --- 5. INPUT HANDLING ---
        document.addEventListener('mousemove', (e) => {
            state.isIdle = false;
            state.targetSmile = 1.0;

            // Map Mouse to Logical 0-320 Space (relative to viewport)
            // Note: Spec asked for 0-320. We map screen 0-W to logic 0-320
            const rx = e.clientX / window.innerWidth;
            const ry = e.clientY / window.innerHeight;
            state.mouse.x = rx * SPEC.logic;
            state.mouse.y = ry * SPEC.logic;
        });

        document.addEventListener('mouseleave', () => {
            state.isIdle = true;
            state.targetSmile = -0.5;
            state.mouse.x = SPEC.center.x;
            state.mouse.y = SPEC.center.y + 100; // Look down
        });

        // --- 6. RENDER FRAME ---
        const render = () => {
            // A. PHYSICS STEP
            // Smile Lerp
            state.smile += (state.targetSmile - state.smile) * 0.12;

            // Eye Convergence Logic
            const solveEye = (eyeCX, eyeCY, currentPos) => {
                // Base Vector to Mouse
                let dx = state.mouse.x - eyeCX;
                let dy = state.mouse.y - eyeCY;

                // Normalize direction
                const dist = Math.sqrt(dx * dx + dy * dy);
                const nx = dx / (dist || 1);
                const ny = dy / (dist || 1);

                // Convergence Check
                const distFromCenter = Math.abs(state.mouse.x - SPEC.center.x);
                let convergenceX = 0;
                if (distFromCenter < 40) {
                    const strength = 1.0 - (distFromCenter / 40);
                    // Add inward convergence
                    convergenceX = (eyeCX < SPEC.center.x) ? 16 * strength : -16 * strength;
                }

                // Target Pupil Offset (Max 11px radius)
                const lookMag = Math.min(dist, 11);
                const targetX = (nx * lookMag) + convergenceX;
                const targetY = (ny * lookMag);

                // Spring Physics
                currentPos.vx += (targetX - currentPos.x) * 0.2;
                currentPos.vy += (targetY - currentPos.y) * 0.2;
                currentPos.vx *= 0.7; // Drag
                currentPos.vy *= 0.7;
                currentPos.x += currentPos.vx;
                currentPos.y += currentPos.vy;
            };

            // Eye Centers
            const leftEyeCX = 125 + SPEC.center.x - 160; // 125
            const rightEyeCX = 195 + SPEC.center.x - 160; // 195
            const eyeCY = SPEC.center.y;

            solveEye(125, 153.6, state.pupilL);
            solveEye(195, 153.6, state.pupilR);


            // B. DRAWING PIPELINE
            const logicCanvas = document.createElement('canvas'); // Temp Logic Buffer
            logicCanvas.width = SPEC.logic;
            logicCanvas.height = SPEC.logic;
            const lCtx = logicCanvas.getContext('2d');

            // 1. Draw White Shapes (Source)
            lCtx.fillStyle = '#FFFFFF';
            lCtx.strokeStyle = '#FFFFFF';
            lCtx.lineCap = 'round';
            lCtx.translate(SPEC.center.x, SPEC.center.y);
            lCtx.scale(SPEC.scale, SPEC.scale);
            lCtx.translate(-SPEC.center.x, -SPEC.center.y);

            const cx = SPEC.center.x;
            const cy = SPEC.center.y;

            // Eyes (Containers)
            [125, 195].forEach((ex) => {
                lCtx.beginPath();
                lCtx.ellipse(ex, cy, 16, 22, 0, 0, Math.PI * 2); // 32x44 -> rad 16x22
                lCtx.fill();
            });

            // Brows
            const browY = cy - 30;
            const arch = state.smile * -8;
            [-1, 1].forEach(side => {
                lCtx.save();
                // Pivot around brow center
                const bx = cx + (35 * side);
                lCtx.translate(bx, browY);
                // No rotation in spec per se, just arch. But slight tilt is implied by organics.
                // Using quadratic curve for arch
                lCtx.lineWidth = 6; // Thick center
                lCtx.beginPath();
                lCtx.moveTo(-14, 4); // 28 width approx
                lCtx.quadraticCurveTo(0, -4 + arch, 14, 4);
                lCtx.stroke();
                lCtx.restore();
            });

            // Mouth (Tapered)
            const mouthY = 187.6;
            const mw = 42;
            const mt = 12 + (Math.abs(state.smile) * 10);
            const mCurve = (state.smile > 0) ? state.smile * 25 : state.smile * 35;

            lCtx.beginPath();
            lCtx.moveTo(cx - mw, mouthY); // Left Corner (Sharp)
            // Top Curve
            lCtx.quadraticCurveTo(cx, mouthY + mCurve - mt, cx + mw, mouthY);
            // Bottom Curve
            lCtx.quadraticCurveTo(cx, mouthY + mCurve + mt, cx - mw, mouthY);
            lCtx.fill();


            // 2. Composite Grid (Mask)
            lCtx.globalCompositeOperation = 'source-in';
            lCtx.drawImage(gridCanvas, 0, 0, SPEC.logic, SPEC.logic);

            // 3. Cut Pupils (Destination Out)
            lCtx.globalCompositeOperation = 'destination-out';

            // Left Pupil
            lCtx.beginPath();
            lCtx.arc(125 + state.pupilL.x, 153.6 + state.pupilL.y, 11, 0, Math.PI * 2);
            lCtx.fill();

            // Right Pupil
            lCtx.beginPath();
            lCtx.arc(195 + state.pupilR.x, 153.6 + state.pupilR.y, 11, 0, Math.PI * 2);
            lCtx.fill();


            // C. FINAL RENDER TO SCREEN
            ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);
            // Scale logic buffer to screen
            ctx.drawImage(logicCanvas,
                0, 0, SPEC.logic, SPEC.logic,
                0, 0, stage.clientWidth, stage.clientHeight
            );

            requestAnimationFrame(render);
        };

        render();
    </script>
</body>

</html>