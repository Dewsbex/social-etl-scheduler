<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE SOCRATIC ORB | v125.0</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

        :root {
            --bg-color: #000000;
            --orb-size: min(90vw, 90vh);
        }

        body {
            margin: 0;
            background: var(--bg-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
        }

        .orb-stage {
            position: relative;
            width: var(--orb-size);
            height: var(--orb-size);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .orb-hull {
            position: absolute;
            inset: 0;
            background-image: url('/static/trim_bot.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
        }

        #face-canvas {
            position: absolute;
            z-index: 2;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .ui-layer {
            position: absolute;
            bottom: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #00ffff;
            font-size: 10px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.7;
            letter-spacing: 0.25em;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.5);
        }
    </style>
</head>

<body>

    <div class="orb-stage" id="stage">
        <div class="orb-hull"></div>
        <canvas id="face-canvas"></canvas>
    </div>

    <div class="ui-layer">
        SYSTEM: ONLINE // ENGINE: v125.0 // SOVEREIGN SENTINEL
    </div>

    <script>
        // --- 1. CORE CONFIGURATION (v125.0) ---
        const SPEC = {
            gridRes: 1024,        // High-density rendering
            logicSize: 320,      // Logical coordinate space
            center: { x: 160, y: 153.6 }, // 0.48 shift
            visorScale: 0.85,
            colors: {
                bg: '#000000',
                glow: '#00ffff',
                core: '#ffffff'
            },
            dotsPerAxis: 1000,
            overlap: 1.6
        };

        const canvas = document.getElementById('face-canvas');
        const stage = document.getElementById('stage');
        const ctx = canvas.getContext('2d', { alpha: true });

        // Dual Buffer Architecture
        const buffer = document.createElement('canvas');
        buffer.width = SPEC.logicSize;
        buffer.height = SPEC.logicSize;
        const bCtx = buffer.getContext('2d');

        // State
        let mouseX = 0, mouseY = 0;
        let smileFactor = -0.5; // Starts at Idle Frown
        let targetSmile = -0.5;
        let eyePos = { x: 0, y: 0 };
        let eyeVel = { x: 0, y: 0 };
        let isOffScreen = true;

        // --- 2. SETUP & RESIZE ---
        const init = () => {
            const dpr = window.devicePixelRatio || 1;
            const rect = stage.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
        };
        window.addEventListener('resize', init);
        init();

        // Interaction
        document.addEventListener('mousemove', (e) => {
            isOffScreen = false;
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
            targetSmile = 1.0;
        });

        document.addEventListener('mouseleave', () => {
            isOffScreen = true;
            targetSmile = -0.5;
        });

        // --- 3. RENDERING ENGINE ---
        const drawFaceShapes = () => {
            bCtx.clearRect(0, 0, SPEC.logicSize, SPEC.logicSize);
            bCtx.save();

            // Global Transform
            bCtx.translate(SPEC.center.x, SPEC.center.y);
            bCtx.scale(SPEC.visorScale, SPEC.visorScale);
            bCtx.translate(-SPEC.center.x, -SPEC.center.y);

            const cx = SPEC.center.x;
            const cy = SPEC.center.y;

            // --- 2.1 EYES & HOLLOW PUPILS ---
            const eyeW = 32; const eyeH = 44; const eyeGap = 35;
            const pupilRadius = 11;

            [-1, 1].forEach(side => {
                const ex = cx + (eyeGap * side) + eyePos.x;
                const ey = cy + eyePos.y;

                bCtx.fillStyle = '#FFFFFF';
                bCtx.beginPath();
                bCtx.ellipse(ex, ey, eyeW / 2, eyeH / 2, 0, 0, Math.PI * 2);
                bCtx.fill();

                // Hollow Pupil
                bCtx.globalCompositeOperation = 'destination-out';
                bCtx.beginPath();
                bCtx.arc(ex + (eyePos.x * 0.2), ey + (eyePos.y * 0.2), pupilRadius, 0, Math.PI * 2);
                bCtx.fill();
                bCtx.globalCompositeOperation = 'source-over';
            });

            // --- 2.2 EYEBROWS ---
            const browW = 32;
            const browY = cy - 30;
            const tilt = smileFactor * 15;

            bCtx.strokeStyle = '#FFFFFF';
            bCtx.lineWidth = 4;
            bCtx.lineCap = 'round';

            [-1, 1].forEach(side => {
                const bx = cx + (eyeGap * side) + (eyePos.x * 0.5);
                const by = browY + (eyePos.y * 0.5);

                bCtx.save();
                bCtx.translate(bx, by);
                bCtx.rotate(side * (smileFactor * 0.2));
                bCtx.beginPath();
                bCtx.moveTo(-browW / 2, 5);
                bCtx.quadraticCurveTo(0, -5 - (smileFactor * 5), browW / 2, 5);
                bCtx.stroke();
                bCtx.restore();
            });

            // --- 3. THE MOUTH (DYNAMIC TAPERED BAR) ---
            const mouthW = 42;
            const mouthY = cy + 34;
            // logic: 12 + (abs(smileFactor) * 10)
            const thickness = 6 + (Math.abs(smileFactor) * 5);
            const curviness = (smileFactor > 0) ? smileFactor * 12 : smileFactor * 18;
            const cornerY = (smileFactor < 0) ? -smileFactor * 8 : 0;

            bCtx.fillStyle = '#FFFFFF';
            bCtx.beginPath();
            // Start at Left Corner
            bCtx.moveTo(cx - mouthW, mouthY + cornerY);
            // Top Curve
            bCtx.quadraticCurveTo(cx, mouthY + curviness - thickness, cx + mouthW, mouthY + cornerY);
            // Bottom Curve (meets at corners for tapering)
            bCtx.quadraticCurveTo(cx, mouthY + curviness + thickness, cx - mouthW, mouthY + cornerY);
            bCtx.closePath();
            bCtx.fill();

            bCtx.restore();
        };

        const renderMatrix = () => {
            // physics
            smileFactor += (targetSmile - smileFactor) * 0.12;

            const pX = isOffScreen ? 0 : mouseX * 8;
            const pY = isOffScreen ? 0 : -mouseY * 8;

            eyeVel.x += (pX - eyePos.x) * 0.2;
            eyeVel.y += (pY - eyePos.y) * 0.2;
            eyeVel.x *= 0.7; eyeVel.y *= 0.7;
            eyePos.x += eyeVel.x; eyePos.y += eyeVel.y;

            drawFaceShapes();

            // Clear Main Canvas
            const scale = stage.clientWidth / SPEC.logicSize;
            ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);

            // Rasterize logical buffer to high-res grid
            // We'll read the logical buffer and draw phosphor dots
            const imgData = bCtx.getImageData(0, 0, SPEC.logicSize, SPEC.logicSize).data;
            const dotStep = SPEC.logicSize / SPEC.dotsPerAxis;
            const dotRadius = (dotStep / 2) * SPEC.overlap;

            for (let y = 0; y < SPEC.logicSize; y += dotStep) {
                for (let x = 0; x < SPEC.logicSize; x += dotStep) {
                    const idx = (Math.floor(y) * SPEC.logicSize + Math.floor(x)) * 4;
                    if (imgData[idx + 3] > 120) {
                        const sx = x * scale;
                        const sy = y * scale;
                        const r = dotRadius * scale;

                        // Solid Phosphor Rendering
                        // Outer Glow
                        ctx.beginPath();
                        ctx.arc(sx, sy, r * 0.98, 0, Math.PI * 2);
                        ctx.fillStyle = SPEC.colors.glow;
                        ctx.fill();

                        // Inner Core
                        ctx.beginPath();
                        ctx.arc(sx, sy, r * 0.9, 0, Math.PI * 2);
                        ctx.fillStyle = SPEC.colors.core;
                        ctx.fill();
                    }
                }
            }

            requestAnimationFrame(renderMatrix);
        };

        renderMatrix();
    </script>
</body>

</html>