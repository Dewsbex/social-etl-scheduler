<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>THE SOCRATIC ORB | STANDALONE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&display=swap');

        :root {
            --bg-color: #050505;
            --orb-size: min(90vw, 90vh);
            /* responsive scaling */
        }

        body {
            margin: 0;
            background: var(--bg-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
        }

        /* --- THE ORB CONTAINER --- */
        .orb-stage {
            position: relative;
            width: var(--orb-size);
            height: var(--orb-size);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* --- THE ROBOT HULL (Image) --- */
        .orb-hull {
            position: absolute;
            inset: 0;
            background-image: url('https://github.com/Dewsbex/socratic-orb/blob/main/Blank%20Bot%20Dark%20Avenger.png?raw=true');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;

            /* ALWAYS ON COLOR - NO GRAYSCALE */
            filter: contrast(1.1) brightness(1.1);
            z-index: 1;
        }

        /* --- THE VFD FACE (Canvas) --- */
        #face-canvas {
            position: absolute;
            z-index: 2;
            width: 100%;
            height: 100%;
            /* Glow effect applied here */
            filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.5));
            /* Opacity controlled by JS for Ignition Sequence */
            opacity: 0;
            transition: opacity 0.1s linear;
        }

        /* --- UI OVERLAY --- */
        .ui-layer {
            position: absolute;
            bottom: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #444;
            font-size: 12px;
            pointer-events: none;
            z-index: 10;
            opacity: 0.5;
            letter-spacing: 0.2em;
        }

        .fire-overlay {
            position: absolute;
            top: 0;
            right: 0;
            width: 40%;
            height: 100%;
            /* Stronger Orange/Red Gradient */
            background: radial-gradient(circle at 100% 60%, rgba(255, 60, 0, 0.4), rgba(255, 100, 0, 00) 70%);
            mix-blend-mode: screen;
            /* Screen is more visible on dark backgrounds than color-dodge */
            pointer-events: none;
            z-index: 15;
            filter: blur(20px);
            animation: flicker 2s infinite alternate ease-in-out;
        }

        @keyframes flicker {
            0% {
                opacity: 0.6;
                transform: scale(1.0);
            }

            25% {
                opacity: 0.8;
                transform: scale(1.02);
            }

            50% {
                opacity: 0.5;
                transform: scale(0.98) skewY(2deg);
            }

            75% {
                opacity: 0.7;
                transform: scale(1.01);
            }

            100% {
                opacity: 0.9;
                transform: scale(1.0);
            }
        }
    </style>
</head>

<body>

    <div class="orb-stage" id="stage">
        <div class="orb-hull"></div>
        <canvas id="face-canvas"></canvas>
    </div>

    <div class="fire-overlay"></div>
    <div class="ui-layer"
        style="color: #ff0000; text-shadow: 0 0 10px #ff0000; font-weight: bold; font-size: 14px; opacity: 1.0;">
        SYSTEM: ONLINE // SOCRATIC ENGINE ACTIVE // v5.5 [DEBUG: RED]
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            gridRes: 640,
            scale: 1.2,
            trackingRange: 3,
            colors: {
                bg: '#000000',
                glow: '#00ffff',
                core: '#ffffff'
            },
            faceOffsetY: 90,
            mouthOffsetY: 50
        };

        // --- SETUP ---
        document.body.style.cursor = "url('static/digital_biscuit.png') 32 32, auto";

        const canvas = document.getElementById('face-canvas');
        const stage = document.getElementById('stage');
        const ctx = canvas.getContext('2d');

        // 1. Shapes Buffer
        const shapeCanvas = document.createElement('canvas');
        const sCtx = shapeCanvas.getContext('2d');

        // 2. Pattern Cache
        const patternCanvas = document.createElement('canvas');
        const pCtx = patternCanvas.getContext('2d');

        // State Variables
        let mouseX = 0, mouseY = 0; // Screen normalized (-1 to 1)
        let gridMouseY = 0; // Grid Key for tracking
        let smileFactor = 0;
        let targetSmile = 0;

        // Independent Pupil Tracking
        let pupilL = { x: 0, y: 0 };
        let pupilR = { x: 0, y: 0 };

        // Helper to check interactive distance
        let isEating = false;
        let eatPhase = 0;

        // VISIBILITY STATE
        let faceOpacity = 1.0;
        let targetOpacity = 1.0;

        // --- RESIZE & INIT ---
        const init = () => {
            const rect = stage.getBoundingClientRect();
            if (rect.width === 0) return;

            const dpr = window.devicePixelRatio || 1;

            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            shapeCanvas.width = CONFIG.gridRes;
            shapeCanvas.height = CONFIG.gridRes;

            patternCanvas.width = canvas.width;
            patternCanvas.height = canvas.height;
            pCtx.scale(dpr, dpr);

            const stageW = rect.width;
            const stageH = rect.height;
            const dotSize = stageW / CONFIG.gridRes;
            const radius = (dotSize / 2) * 1.35;

            pCtx.clearRect(0, 0, stageW, stageH);

            for (let y = 0; y < CONFIG.gridRes; y++) {
                const sy = y * dotSize + (dotSize / 2);
                if (sy > stageH) break;

                for (let x = 0; x < CONFIG.gridRes; x++) {
                    const sx = x * dotSize + (dotSize / 2);
                    pCtx.beginPath();
                    pCtx.arc(sx, sy, radius, 0, Math.PI * 2);
                    pCtx.fillStyle = CONFIG.colors.glow;
                    pCtx.fill();
                    pCtx.beginPath();
                    pCtx.arc(sx, sy, radius * 0.6, 0, Math.PI * 2);
                    pCtx.fillStyle = CONFIG.colors.core;
                    pCtx.fill();
                }
            }
        };

        window.addEventListener('resize', init);
        window.addEventListener('DOMContentLoaded', init);
        window.addEventListener('load', init);
        setTimeout(init, 500);

        // --- INPUT TRACKING ---
        document.addEventListener('mousemove', (e) => {
            targetOpacity = 1.0;
            // Normalized -1 to 1
            mouseX = (e.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(e.clientY / window.innerHeight) * 2 + 1;

            // Eating Interaction (using normalized coords)
            const dist = Math.hypot(mouseX, mouseY + 0.3);
            if (dist < 0.25) {
                targetSmile = 1.0;
                isEating = true;
            } else {
                targetSmile = 0.5;
                isEating = false;
            }
        });

        document.addEventListener('mouseleave', () => {
            targetSmile = 0.0;
            isEating = false;
            targetOpacity = 0.5;
        });

        // --- RENDER LOOP ---
        const animate = () => {
            requestAnimationFrame(animate);

            smileFactor += (targetSmile - smileFactor) * 0.1;
            faceOpacity += (targetOpacity - faceOpacity) * 0.1;
            canvas.style.opacity = faceOpacity;

            // --- TRACKING LOGIC ---
            // Map Mouse to Grid Coordinates (approximate for tracking vector)
            // Grid Center is (320, 320). 
            // We apply faceOffset to Y, so "Face Center" is (320, 320 + offset)

            // Convert normalized Mouse to Grid Units relative to center
            const gridMX = mouseX * 320; // +/- 320
            const gridMY = -mouseY * 320; // Flip Y back to canvas coords. +/- 320

            // Eye Centers on Grid relative to (0,0) center point, before global translation
            // Actual drawing happens at (cx +/- gap, cy)
            // cx = 320 (0 relative). cy = 320 * 0.48 = 153.6. 
            // BUT we translate entire face by faceOffsetY (90).
            // So EyeY = 153.6 relative to face anchor, but effectively (153.6 + 90) - 320 relative to screen center?
            // Let's keep it simple: Vector = MousePos - EyePos

            // Center of Canvas is (0,0) in our relative math below
            const eyeY = (CONFIG.gridRes * 0.48) - (CONFIG.gridRes / 2) + CONFIG.faceOffsetY; // Relative to center
            const eyeGap = 28;

            // Left Eye (-28, eyeY)
            let dxL = gridMX - (-eyeGap);
            let dyL = gridMY - eyeY;
            let angL = Math.atan2(dyL, dxL);
            let distL = Math.min(4, Math.hypot(dxL, dyL) * 0.05); // Limit pupil movement

            let txL = Math.cos(angL) * distL;
            let tyL = Math.sin(angL) * distL;

            pupilL.x += (txL - pupilL.x) * 0.2;
            pupilL.y += (tyL - pupilL.y) * 0.2;

            // Right Eye (+28, eyeY)
            let dxR = gridMX - (eyeGap);
            let dyR = gridMY - eyeY;
            let angR = Math.atan2(dyR, dxR);
            let distR = Math.min(4, Math.hypot(dxR, dyR) * 0.05);

            let txR = Math.cos(angR) * distR;
            let tyR = Math.sin(angR) * distR;

            pupilR.x += (txR - pupilR.x) * 0.2;
            pupilR.y += (tyR - pupilR.y) * 0.2;

            // --- DRAWING ---
            sCtx.clearRect(0, 0, CONFIG.gridRes, CONFIG.gridRes);
            sCtx.save();

            sCtx.translate(CONFIG.gridRes / 2, (CONFIG.gridRes / 2) + CONFIG.faceOffsetY);
            sCtx.scale(CONFIG.scale, CONFIG.scale);
            sCtx.translate(-CONFIG.gridRes / 2, -CONFIG.gridRes / 2);
            sCtx.fillStyle = '#FFF';

            const cx = CONFIG.gridRes / 2;
            const cy = CONFIG.gridRes * 0.48;
            const eyeW = 16; const eyeH = 22; const pupilSize = 3.5;

            // Eyes
            [-1, 1].forEach(side => {
                const eyeCx = cx + (eyeGap * side);
                sCtx.beginPath();
                sCtx.ellipse(eyeCx, cy, eyeW / 2, eyeH / 2, 0, 0, Math.PI * 2);
                sCtx.fill();

                sCtx.globalCompositeOperation = 'destination-out';
                sCtx.beginPath();

                // Select Independent Pupil
                const pX = (side === -1) ? pupilL.x : pupilR.x;
                const pY = (side === -1) ? pupilL.y : pupilR.y;

                sCtx.arc(eyeCx + pX, cy + pY, pupilSize, 0, Math.PI * 2);
                sCtx.fill();
                sCtx.globalCompositeOperation = 'source-over';
            });

            // Brows - LOWERED AGAIN
            sCtx.lineCap = 'round'; sCtx.lineWidth = 4;
            const browLift = (smileFactor * 4) - (Math.abs(mouseY) * 2);
            const browY = cy - 10 - browLift; // Even Closer (was -14)
            const browW = 24; const browAngle = smileFactor * 0.15;

            sCtx.strokeStyle = '#FFF';
            sCtx.save(); sCtx.translate(cx - eyeGap, browY); sCtx.rotate(-browAngle);
            sCtx.beginPath(); sCtx.moveTo(-browW / 2, 4); sCtx.quadraticCurveTo(0, -2, browW / 2, 4); sCtx.stroke(); sCtx.restore();
            sCtx.save(); sCtx.translate(cx + eyeGap, browY); sCtx.rotate(browAngle);
            sCtx.beginPath(); sCtx.moveTo(-browW / 2, 4); sCtx.quadraticCurveTo(0, -2, browW / 2, 4); sCtx.stroke(); sCtx.restore();

            // Mouth (Eating Logic)
            const mouthY = cy + CONFIG.mouthOffsetY;
            const mouthW = 32;

            if (isEating) {
                eatPhase += 0.4; // Chew speed
                const chewHeight = Math.sin(eatPhase) * 10 + 12; // Opens and closes
                sCtx.beginPath();
                sCtx.ellipse(cx, mouthY, mouthW / 1.5, chewHeight, 0, 0, Math.PI * 2);
                sCtx.fill();
            } else {
                eatPhase = 0;
                const smileDepth = smileFactor * 12;
                if (smileFactor > 0.1) {
                    sCtx.beginPath();
                    sCtx.moveTo(cx - mouthW, mouthY);
                    sCtx.quadraticCurveTo(cx, mouthY + smileDepth, cx + mouthW, mouthY);
                    sCtx.quadraticCurveTo(cx, mouthY + smileDepth + 8, cx - mouthW, mouthY);
                    sCtx.fill();
                } else {
                    sCtx.beginPath();
                    sCtx.moveTo(cx - mouthW, mouthY);
                    sCtx.quadraticCurveTo(cx, mouthY, cx + mouthW, mouthY);
                    sCtx.stroke();
                }
            }
            sCtx.restore();

            // 3. Composite
            ctx.clearRect(0, 0, canvas.width / window.devicePixelRatio, canvas.height / window.devicePixelRatio);

            ctx.save();
            ctx.scale(1 / window.devicePixelRatio, 1 / window.devicePixelRatio);

            // Draw Shape (Destination)
            ctx.drawImage(shapeCanvas, 0, 0, canvas.width, canvas.height);

            // Mask with Pattern (Source-In)
            ctx.globalCompositeOperation = 'source-in';
            ctx.drawImage(patternCanvas, 0, 0);

            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        };

        animate();
    </script>
</body>

</html>