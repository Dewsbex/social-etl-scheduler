<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Socratic Orb: Dark Avenger (v125.3)</title>
    <style>
        body {
            background-color: #0d0d0d;
            /* Matches dark vignette of the image */
            margin: 0;
            height: 100vh;
            width: 100vw;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* 1. THE CHASSIS CONTAINER 
           Locks the aspect ratio to the image dimensions.
           Ensures the 'canvas' coordinates are always relative to the bot, not the window.
        */
        #chassis {
            position: relative;
            /* The asset is square. We lock the container to 1:1 */
            aspect-ratio: 1 / 1;

            /* Responsive Sizing: 
               Fills 95% of whichever is smaller (width or height).
               This ensures the whole bot is always visible. */
            width: min(95vw, 95vh);
            height: min(95vw, 95vh);

            /* The Robot Image */
            background: url('Trim%20Bot%20Dark%20Avenger.jpg') no-repeat center center;
            /* Fallback to GitHub raw content if local file missing */
            background-image: url('Trim%20Bot%20Dark%20Avenger.jpg'), url('https://raw.githubusercontent.com/Dewsbex/The-socratic-orb/main/Trim%20Bot%20Dark%20Avenger.jpg');
            background-size: contain;
        }

        /* 2. THE VISOR MAPPING (CALIBRATED TO JPG)
           These % values map the canvas to the black circular glass.
        */
        canvas {
            position: absolute;

            /* Y-AXIS: Distance from top of the horns to start of glass */
            top: 27%;

            /* WIDTH: The diameter of the glass circle relative to full image width */
            width: 41%;

            /* X-AXIS: Center horizontally */
            left: 50%;
            transform: translateX(-50%);

            /* Force square aspect ratio for the face logic */
            aspect-ratio: 1 / 1;

            /* Visual styles */
            image-rendering: pixelated;
            /* border: 1px solid rgba(0, 255, 255, 0.2); Un-comment to debug alignment */
            border-radius: 50%;
            /* Optional: Clips corners if they bleed out */
            /* Optional: Clips corners if they bleed out */
        }
        
        /* 3. LOGISTICS TERMINAL OVERLAY */
        #logistics-terminal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80vw;
            height: 70vh;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.1);
            color: #00ffff;
            font-family: 'Courier New', Courier, monospace;
            z-index: 1000;
            display: none; /* Hidden by default, toggled via hotkey or auto */
            flex-direction: column;
            padding: 20px;
            overflow: hidden;
        }
        
        #terminal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0, 255, 255, 0.3);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .event-card {
            background: rgba(0, 255, 255, 0.05);
            border: 1px solid rgba(0, 255, 255, 0.2);
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .event-info {
             font-size: 0.9rem;
        }
        
        .event-actions button {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid lime;
            color: lime;
            padding: 5px 10px;
            cursor: pointer;
            margin-left: 5px;
            font-family: inherit;
        }
        
        .event-actions button.reject {
            border-color: red;
            color: red;
        }
        
        .event-actions button:hover {
            background: rgba(0, 255, 255, 0.1);
        }

        #terminal-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 2000;
        }
        
        .hud-btn {
             background: rgba(0,0,0,0.5);
             border: 1px solid #00ffff;
             color: #00ffff;
             padding: 8px 16px;
             cursor: pointer;
             font-family: 'Courier New';
             backdrop-filter: blur(4px);
        }
    </style>
</head>

<body>

    <div id="chassis">
        <canvas id="orbCanvas" width="1024" height="1024"></canvas>
    </div>

    <div id="terminal-controls">
         <button class="hud-btn" onclick="toggleTerminal()">LOGISTICS TERMINAL</button>
         <button class="hud-btn" onclick="triggerScan()">TRIGGER SCAN</button>
    </div>

    <div id="logistics-terminal">
        <div id="terminal-header">
            <span>> LOGISTICS OFFICER // PENDING APPROVALS</span>
            <span id="close-btn" style="cursor:pointer" onclick="toggleTerminal()">[X]</span>
        </div>
        <div id="event-list" style="overflow-y: auto; flex-grow: 1;">
            <!-- Events injected here -->
            <div style="text-align:center; margin-top: 20px; color: #555;">NO PENDING EVENTS</div>
        </div>
    </div>

    <script>
        /**
         * SOCRATIC ORB VFD - DARK AVENGER BUILD (v125.3)
         * -------------------------------------------------
         * SPECIFICATION:
         * - Asset: Trim Bot Dark Avenger.jpg
         * - Logic: 320x320 coord space mapped to 1024px physical grid.
         * - Physics: "Antigravity" smooth lerp + convergence zone tracking.
         */

        // --- CONFIGURATION ---
        const CONFIG = {
            centerX: 160,
            centerY: 153.6,
            scale: 0.85,    // Global scale to float face inside the aperture
            eyeGap: 35,     // Distance from center to eye
            eyeW: 32,
            eyeH: 44,
            pupilRadius: 11,
            colors: { bg: '#000000', glow: '#00ffff', core: '#ffffff' },
            physics: { accel: 0.2, drag: 0.7, blend: 0.12 }
        };

        // --- STATE ---
        let state = {
            mouse: { x: 0, y: 0, active: false },
            smileFactor: -0.5, // Start with Idle Frown
            pupils: {
                left: { x: 0, y: 0, vx: 0, vy: 0 },
                right: { x: 0, y: 0, vx: 0, vy: 0 }
            }
        };

        // --- 1. INIT VFD TEXTURE (1024x1024) ---
        // We pre-render the dots to improve performance
        const gridCanvas = document.createElement('canvas');
        gridCanvas.width = 1024;
        gridCanvas.height = 1024;
        const gridCtx = gridCanvas.getContext('2d');

        function initGrid() {
            // Black background
            gridCtx.fillStyle = CONFIG.colors.bg;
            gridCtx.fillRect(0, 0, 1024, 1024);

            const dotSize = 1024 / 1000; // 1000 dots density
            const radius = dotSize * 0.8;

            for (let y = 0; y < 1024; y += dotSize * 1.2) {
                for (let x = 0; x < 1024; x += dotSize * 1.2) {
                    // 1. Cyan Glow (Outer)
                    gridCtx.fillStyle = CONFIG.colors.glow;
                    gridCtx.beginPath();
                    gridCtx.arc(x, y, radius * 1.6, 0, Math.PI * 2);
                    gridCtx.fill();
                    // 2. White Core (Inner)
                    gridCtx.fillStyle = CONFIG.colors.core;
                    gridCtx.beginPath();
                    gridCtx.arc(x, y, radius * 0.9, 0, Math.PI * 2);
                    gridCtx.fill();
                }
            }
        }
        initGrid();

        // --- 2. RENDER LOOP ---
        const canvas = document.getElementById('orbCanvas');
        const ctx = canvas.getContext('2d');
        const L_SCALE = 1024 / 320; // Ratio of Physical(1024) to Logical(320)

        function draw() {
            updatePhysics();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // --- LAYER A: WHITE SHAPES ---
            // We draw the eyes, mouth, and brows in pure white.
            ctx.save();
            // Transform: 1. Scale to physical -> 2. Center -> 3. Apply Visor Scale (0.85)
            ctx.scale(L_SCALE, L_SCALE);
            ctx.translate(CONFIG.centerX, CONFIG.centerY);
            ctx.scale(CONFIG.scale, CONFIG.scale);
            ctx.translate(-CONFIG.centerX, -CONFIG.centerY);

            ctx.fillStyle = '#ffffff';
            drawEyeContainer(CONFIG.centerX - CONFIG.eyeGap);
            drawEyeContainer(CONFIG.centerX + CONFIG.eyeGap);
            drawMouth();
            drawBrows();
            ctx.restore();

            // --- LAYER B: GRID MASK (Source-In) ---
            // Keeps grid pixels ONLY where white shapes exist
            ctx.globalCompositeOperation = 'source-in';
            ctx.drawImage(gridCanvas, 0, 0);

            // --- LAYER C: PUPIL CUTOUT (Destination-Out) ---
            // Removes pixels to create the hollow pupil effect
            ctx.globalCompositeOperation = 'destination-out';
            ctx.save();
            ctx.scale(L_SCALE, L_SCALE);
            ctx.translate(CONFIG.centerX, CONFIG.centerY);
            ctx.scale(CONFIG.scale, CONFIG.scale);
            ctx.translate(-CONFIG.centerX, -CONFIG.centerY);

            drawPupil('left', -CONFIG.eyeGap);
            drawPupil('right', CONFIG.eyeGap);
            ctx.restore();

            // Reset for next frame
            ctx.globalCompositeOperation = 'source-over';
            requestAnimationFrame(draw);
        }

        // --- 3. GEOMETRY DRAWING ---
        function drawEyeContainer(x) {
            ctx.beginPath();
            ctx.ellipse(x, CONFIG.centerY, CONFIG.eyeW / 2, CONFIG.eyeH / 2, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawMouth() {
            const s = state.smileFactor;
            const mouthW = 42;
            const mouthY = 187.6;
            // Taper Logic: Thick center, 0px ends
            const centerThickness = 12 + (Math.abs(s) * 10);
            const curviness = s > 0 ? s * 25 : s * 35;
            const cornerY = mouthY + (s < 0 ? -s * 16 : 0);

            ctx.beginPath();
            ctx.moveTo(CONFIG.centerX - mouthW, cornerY); // Left Corner
            // Top Curve
            ctx.quadraticCurveTo(CONFIG.centerX, mouthY + curviness - (centerThickness / 2), CONFIG.centerX + mouthW, cornerY);
            // Bottom Curve
            ctx.quadraticCurveTo(CONFIG.centerX, mouthY + curviness + (centerThickness / 2), CONFIG.centerX - mouthW, cornerY);
            ctx.fill();
        }

        function drawBrows() {
            const browY = CONFIG.centerY - 30;
            const arch = state.smileFactor * -8; // Arch Up (-) or Down (+)

            drawOneBrow(CONFIG.centerX - CONFIG.eyeGap, browY, arch);
            drawOneBrow(CONFIG.centerX + CONFIG.eyeGap, browY, arch);
        }

        function drawOneBrow(cx, y, arch) {
            const w = 16;
            ctx.beginPath();
            ctx.moveTo(cx - w, y);
            ctx.quadraticCurveTo(cx, y + arch, cx + w, y); // Top
            ctx.quadraticCurveTo(cx, y + arch + 6, cx - w, y); // Bottom (6px thick)
            ctx.fill();
        }

        function drawPupil(side, xOffset) {
            const p = state.pupils[side];
            ctx.beginPath();
            ctx.arc((CONFIG.centerX + xOffset) + p.x, CONFIG.centerY + p.y, CONFIG.pupilRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        // --- 4. PHYSICS & TRACKING ---
        function updatePhysics() {
            // 1. Smile Lerp
            const targetSmile = state.mouse.active ? 1.0 : -0.5;
            state.smileFactor += (targetSmile - state.smileFactor) * CONFIG.physics.blend;

            // 2. Pupil Physics
            updatePupilVec('left', -CONFIG.eyeGap);
            updatePupilVec('right', CONFIG.eyeGap);
        }

        function updatePupilVec(side, xOffset) {
            const pupil = state.pupils[side];
            let targetX = 0, targetY = 0;

            if (state.mouse.active) {
                const eyeCX = CONFIG.centerX + xOffset;
                let dx = state.mouse.x - eyeCX;
                let dy = state.mouse.y - CONFIG.centerY;

                // Convergence Zone (Cross-eyes when near center)
                const distFromCenter = Math.abs(state.mouse.x - CONFIG.centerX);
                // Zone width: 40px
                if (distFromCenter < 40) {
                    const strength = 1.0 - (distFromCenter / 40);
                    const offset = 16 * strength; // Max 16px inward shift
                    if (side === 'left') dx += offset;
                    if (side === 'right') dx -= offset;
                }

                // Vector Clamp (Max Radius 11)
                const angle = Math.atan2(dy, dx);
                const dist = Math.min(Math.sqrt(dx * dx + dy * dy), 11);

                targetX = Math.cos(angle) * dist;
                targetY = Math.sin(angle) * dist;
            }

            // Spring Physics
            pupil.vx += (targetX - pupil.x) * CONFIG.physics.accel;
            pupil.vy += (targetY - pupil.y) * CONFIG.physics.accel;
            pupil.vx *= CONFIG.physics.drag;
            pupil.vy *= CONFIG.physics.drag;
            pupil.x += pupil.vx;
            pupil.y += pupil.vy;
        }

        // --- 5. RESPONSIVE INPUT HANDLER ---
        window.addEventListener('mousemove', (e) => {
            state.mouse.active = true;

            // Dynamic Scale Calculation
            // We map the physical mouse coordinates to the logical 320x320 space
            // accounting for the current size of the canvas (which shrinks/grows with the bot image)
            const rect = canvas.getBoundingClientRect();

            // Ratio: 320 logical units / Current Pixel Width
            const scaleX = 320 / rect.width;
            const scaleY = 320 / rect.height;

            const rawX = (e.clientX - rect.left) * scaleX;
            const rawY = (e.clientY - rect.top) * scaleY;

            // Reverse the 'CONFIG.scale' (0.85) to find true logical target
            state.mouse.x = (rawX - CONFIG.centerX) / CONFIG.scale + CONFIG.centerX;
            state.mouse.y = (rawY - CONFIG.centerY) / CONFIG.scale + CONFIG.centerY;
        });

        window.addEventListener('mouseleave', () => {
            state.mouse.active = false;
        });

        // --- 6. LOGISTICS UI LOGIC ---
        const terminal = document.getElementById('logistics-terminal');
        const eventList = document.getElementById('event-list');

        function toggleTerminal() {
            if (terminal.style.display === 'flex') {
                terminal.style.display = 'none';
            } else {
                terminal.style.display = 'flex';
                fetchPendingEvents();
            }
        }
        
        function triggerScan() {
             fetch('/api/trigger', { method: 'POST' })
             .then(r => r.json())
             .then(data => alert(data.message))
             .catch(e => alert("Trigger Failed"));
        }

        function fetchPendingEvents() {
            fetch('/api/events/pending')
                .then(res => res.json())
                .then(events => {
                    renderEvents(events);
                })
                .catch(err => console.error("Poll failed", err));
        }

        function renderEvents(events) {
            eventList.innerHTML = '';
            if (events.length === 0) {
                eventList.innerHTML = '<div style="text-align:center; margin-top: 20px; color: #555;">NO PENDING EVENTS</div>';
                return;
            }

            events.forEach(evt => {
                const card = document.createElement('div');
                card.className = 'event-card';
                card.innerHTML = `
                    <div class="event-info">
                        <strong>${evt.summary}</strong><br>
                        <span style="color: #aaa;">${evt.start.dateTime}</span><br>
                        <small>Loc: ${evt.location || 'N/A'}</small>
                    </div>
                    <div class="event-actions">
                        <button onclick="approveEvent('${evt.id}')">APPROVE</button>
                        <button class="reject" onclick="rejectEvent('${evt.id}')">REJECT</button>
                    </div>
                `;
                eventList.appendChild(card);
            });
        }

        function approveEvent(id) {
            fetch('/api/events/approve', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({id: id})
            })
            .then(res => res.json())
            .then(data => {
                console.log(data);
                fetchPendingEvents(); // Refresh
            });
        }

        function rejectEvent(id) {
            fetch('/api/events/reject', {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({id: id})
            })
            .then(res => res.json())
            .then(data => {
                console.log(data);
                fetchPendingEvents(); // Refresh
            });
        }
        
        // Auto-refresh if open
        setInterval(() => {
            if(terminal.style.display === 'flex') fetchPendingEvents();
        }, 5000);

        // START ENGINE
        requestAnimationFrame(draw);

    </script>
</body>

</html>