<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>THE SOCRATIC ORB | STATIC HULL</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap');

        :root {
            --bg-color: #050505;
            /* Force a square aspect ratio that fits within the viewport */
            --stage-size: min(95vmin, 95vmin);
        }

        body {
            margin: 0;
            background: var(--bg-color);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            cursor: crosshair;
        }

        /* --- THE STAGE --- */
        .orb-stage {
            position: relative;
            width: var(--stage-size);
            height: var(--stage-size);
            display: grid;
            place-items: center;
        }

        /* --- LAYER 1: THE HULL (Always Full Color) --- */
        .orb-hull {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('https://raw.githubusercontent.com/Dewsbex/Vibe-Station-Alpha/main/Blank%20Bot%20Dark%20Avenger.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: 1;
        }

        /* --- LAYER 2: THE SOUL (VFD Face) --- */
        canvas#face-canvas {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Permanent VFD Glow */
            filter: drop-shadow(0 0 15px rgba(0, 255, 255, 0.6));
        }

        /* --- LAYER 3: UI OVERLAY --- */
        .ui-layer {
            position: absolute;
            bottom: 30px;
            width: 100%;
            text-align: center;
            color: rgba(0, 255, 255, 0.4);
            font-size: 10px;
            letter-spacing: 0.3em;
            pointer-events: none;
            z-index: 20;
            text-shadow: 0 0 5px rgba(0, 255, 255, 0.2);
        }
    </style>
</head>

<body>

    <div class="orb-stage">
        <div class="orb-hull"></div>
        <canvas id="face-canvas"></canvas>
    </div>

    <div class="ui-layer">
        SOCRATIC_ENGINE // V129 // STABLE
    </div>

    <script>
        /**
         * THE SOCRATIC ENGINE (V129 - NO COLOR POP)
         * - Static Hull Background
         * - Optimized Sprite Rendering
         * - Spring Physics for Eyes
         */

        const CONFIG = {
            gridRes: 128,        // 128x128 physical dot matrix
            renderScale: 0.38,   // Calibrated fit for the glass bezel
            trackingForce: 0.08, // Spring stiffness
            friction: 0.82,      // Damping
            colors: {
                bg: '#001a1a',   // Dark teal backing
                glow: '#00ffff', // Cyan
                core: '#ffffff'  // White
            }
        };

        // --- SETUP ---
        const canvas = document.getElementById('face-canvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        const stage = document.querySelector('.orb-stage');

        // Virtual Buffer (Draws shapes)
        const buffer = document.createElement('canvas');
        buffer.width = CONFIG.gridRes;
        buffer.height = CONFIG.gridRes;
        const bCtx = buffer.getContext('2d');

        // Dot Sprite (Pre-rendered for performance)
        const dotSprite = document.createElement('canvas');
        dotSprite.width = 32; dotSprite.height = 32;
        const dCtx = dotSprite.getContext('2d');
        const cx = 16, cy = 16, r = 14;
        // Pre-draw the glowing dot
        dCtx.beginPath(); dCtx.arc(cx, cy, r, 0, Math.PI * 2); dCtx.fillStyle = CONFIG.colors.bg; dCtx.fill();
        dCtx.beginPath(); dCtx.arc(cx, cy, r * 0.8, 0, Math.PI * 2); dCtx.fillStyle = CONFIG.colors.glow; dCtx.fill();
        dCtx.beginPath(); dCtx.arc(cx, cy, r * 0.4, 0, Math.PI * 2); dCtx.fillStyle = CONFIG.colors.core; dCtx.fill();

        // State
        let mouse = { x: 0, y: 0 };
        let smile = { current: 0, target: 0 };
        let eyes = { x: 0, y: 0, vx: 0, vy: 0 };
        let time = 0;
        let idleTimer;

        // --- RESIZE ---
        function resize() {
            const rect = stage.getBoundingClientRect();
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = rect.height * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            ctx.imageSmoothingEnabled = false;
        }
        window.addEventListener('resize', resize);
        resize();

        // --- INPUT TRACKING ---
        document.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            // Interaction: Smile when active
            smile.target = 1.0;

            clearTimeout(idleTimer);
            idleTimer = setTimeout(() => {
                smile.target = 0.0; // Reset smile on idle
            }, 2000);
        });

        // --- ANIMATION LOOP ---
        function frame() {
            requestAnimationFrame(frame);
            time += 0.05;

            // 1. PHYSICS
            smile.current += (smile.target - smile.current) * 0.1;

            // Eye Springs
            let tx = mouse.x * 6;
            let ty = -mouse.y * 6;

            let ax = (tx - eyes.x) * CONFIG.trackingForce;
            let ay = (ty - eyes.y) * CONFIG.trackingForce;

            eyes.vx += ax;
            eyes.vy += ay;
            eyes.vx *= CONFIG.friction;
            eyes.vy *= CONFIG.friction;
            eyes.x += eyes.vx;
            eyes.y += eyes.vy;

            // 2. DRAW SHAPES (To Buffer)
            bCtx.clearRect(0, 0, CONFIG.gridRes, CONFIG.gridRes);
            bCtx.save();

            const center = CONFIG.gridRes / 2;
            bCtx.translate(center, center);
            bCtx.scale(CONFIG.renderScale, CONFIG.renderScale);
            bCtx.fillStyle = '#FFF';
            bCtx.strokeStyle = '#FFF';
            bCtx.lineCap = 'round';
            bCtx.lineJoin = 'round';

            // --> EYES
            const eyeGap = 28;
            const blink = Math.abs(Math.sin(time)) > 0.99 ? 0.2 : 1;
            const eyeH = 22 * blink;

            [-1, 1].forEach(dir => {
                bCtx.beginPath();
                bCtx.ellipse(
                    (eyeGap * dir) + eyes.x,
                    eyes.y - 10,
                    7, eyeH, 0, 0, Math.PI * 2
                );
                bCtx.fill();
            });

            // --> BROWS
            const browY = -28 + (eyes.y * 0.5);
            const browRot = smile.current * 0.2;
            bCtx.lineWidth = 5;

            [-1, 1].forEach(dir => {
                bCtx.save();
                bCtx.translate((eyeGap * dir) + eyes.x, browY);
                bCtx.rotate(dir * (dir === -1 ? -browRot : browRot));
                bCtx.beginPath();
                bCtx.moveTo(-12, 0);
                bCtx.quadraticCurveTo(0, -5 - (smile.current * 4), 12, 0);
                bCtx.stroke();
                bCtx.restore();
            });

            // --> MOUTH
            const mouthY = 25;
            const mouthW = 30;
            const smileDepth = smile.current * 15;

            bCtx.beginPath();
            if (smile.current > 0.1) {
                // Smile
                bCtx.moveTo(-mouthW, mouthY);
                bCtx.quadraticCurveTo(0, mouthY + smileDepth + 8, mouthW, mouthY);
                bCtx.quadraticCurveTo(0, mouthY + smileDepth, -mouthW, mouthY);
                bCtx.fill();
            } else {
                // Neutral
                bCtx.moveTo(-mouthW, mouthY);
                bCtx.quadraticCurveTo(0, mouthY + 2, mouthW, mouthY);
                bCtx.stroke();
            }

            bCtx.restore();

            // 3. RASTERIZE
            const stageW = stage.clientWidth;
            const dotSize = stageW / CONFIG.gridRes;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const pixelData = bCtx.getImageData(0, 0, CONFIG.gridRes, CONFIG.gridRes).data;

            for (let i = 0; i < pixelData.length; i += 4) {
                if (pixelData[i + 3] > 64) {
                    const index = i / 4;
                    const x = (index % CONFIG.gridRes);
                    const y = Math.floor(index / CONFIG.gridRes);

                    ctx.drawImage(
                        dotSprite,
                        x * dotSize,
                        y * dotSize,
                        dotSize * 1.1,
                        dotSize * 1.1
                    );
                }
            }
        }

        // Start
        frame();

    </script>
</body>

</html>